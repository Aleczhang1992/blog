因为本章讲的是函数式编程，所以立场上更加偏向函数而非 OO 的概念。

### 什么是函数式编程

函数式编程: 数据在由纯函数组成的管道中传递。

> 函数式编程可以用简单如`交换律、结合律、分配律`的数学之法来帮我们简化代码的实现。

### 函数是一等公民

```js
const demo = (callback) => ajaxCall((json) => callback(json))

// 可以这样写

const demo = ajaxCall // 需要 ajaxCall 函数做参数的扩充，这样子相对上面易懂
```

如果 `ajaxCall` 函数参数是未知的, 那每次修改依然不便, 因此引人 `curry` 函数。

### 柯里化(curry)

如下是一个加法函数:

```js
var add = (a, b, c) => a + b + c

add(1, 2, 3) // 6
```

假如有这样一个 `curry` 函数, 用其包装 `add` 函数后返回一个新的函数 `curryAdd`, 我们可以将参数 `a、b` 进行分开传递进行调用。

```js
var curryAdd = curry(add)

// 以下输出结果都相同
curryAdd(1, 2, 3) // 6
curryAdd(1, 2)(3) // 6
curryAdd(1)(2)(3) // 6
curryAdd(1)(2, 3) // 6
```

#### 动手实现一个 curry 函数

核心思路: 若传进去的参数个数未达到 `curryAdd` 的个数，则将参数缓存在闭包变量 lists 中:

```js
function curry(fn, ...args) {
  const length = fn.length
  let lists = args || []

  let listLen
  return function (..._args) {
    lists = [...lists, ..._args]
    listLen = lists.length

    if (listLen < length) {
      const that = lists
      lists = []
      return curry(fn, ...that)
    } else if (listLen === length) {
      const that = lists
      lists = []
      return fn.apply(this, that)
    }
  }
}
```

### 代码组合(compose)

现在有 `toUpperCase`、`reverse`、`head` 三个函数, 分别如下:

```js
var toUpperCase = (str) => str.toUpperCase()
var reverse = (arr) => arr.reverse()
var head = (arr) => arr[0]
```

接着使用它们实现将数组末位元素大写化输出, 可以这样做:

```js
var reverseHeadUpperCase = (arr) => toUpperCase(head(reverse(arr)))

reverseHeadUpperCase(['apple', 'banana', 'peach']) // "PEACH"
```

此时在构建 `reverseHeadUpperCase` 函数的时候, 必须手动声明传入参数 arr, 是否能提供一个 `compose` 函数让使用者更加友好的使用呢? 类似如下形式:

```js
var reverseHeadUpperCase = compose(toUpperCase, head, reverse)

reverseHeadUpperCase(['apple', 'banana', 'peach']) // "PEACH"
```

此外 `compose` 函数符合`结合律`, 我们可以这样子使用:

```js
compose(compose(toUpperCase, head), reverse)
compose(toUpperCase, compose(head, reverse))
```

以上两种写法与 `compose(toUpperCase, head, reverse)` 的效果完全相同, 都是依次从右到左执行传参中的函数。

此外 `compose` 和 `map` 一起使用时也有相关的结合律, 以下两种写法效果相等

```js
compose(map(f), map(g))
map(compose(f, g))
```

#### 动手实现一个 compose 函数

代码精华集中在一行之内, 其为众多开源库(比如 Redux) 所采用。

```js
var compose = (...args) => (initValue) => args.reduceRight((a, c) => c(a), initValue)
```

### 范畴论

范畴论是数学中的一个分支。可以将范畴理解为一个容器, 把原来对值的操作，现转为对容器的操作。如下图:

![](http://with.muyunyun.cn/c65fa1b63dbe9fa0a0771e7e561dc85b.jpg-200)

> 学习函数式编程就是学习各种函子的过程。

函数式编程中, `函子(Functor)` 是实现了 `map` 函数的容器, 下文中将函子视为范畴，模型可表示如下:

```js
class Functor {
  constructor(value) {
    this.value = value
  }

  map(fn) {
    return new Functor(fn(this.value))
  }
}
```

但是在函数式编程中, 要避免使用 `new` 这种面向对象的编程方式, 取而代之对外暴露了一个 `of` 的接口, 也称为 `pointed functor`。

```js
Functor.of = value => new Functor(value)
```

#### Maybe 函子

`Maybe 函子`是为了解决 `this.value` 为 null 的情形, 用法如下:

```js
Maybe.of(null).map(r => r.toUpperCase()) // null
Maybe.of('m').map(r => r.toUpperCase())  // Maybe {value: "M"}
```

实现代码如下:

```js
class Maybe {
  constructor(value) {
    this.value = value
  }

  map(fn) {
    return this.value ? new Maybe(fn(this.value)) : null
  }
}

Maybe.of = value => new Maybe(value)
```

#### Either 函子

`Either 函子` 是为了对应 `if...else...` 的语法, 即`非左即右`。因此可以将之拆分为 `Left` 和 `Right` 两个函子, 它们的用法如下:

```js
Left.of(1).map(r => r + 1)  // Left {value: 1}

Right.of(1).map(r => r + 1) // Right {value: 2}
```

`Left 函子`实现代码如下:

```js
class Left {
  constructor(value) {
    this.value = value
  }

  map(fn) {
    return this
  }
}

Left.of = value => new Left(value)
```

`Right 函子`实现代码如下(其实就是上面的 `Functor`):

```js
class Right {
  constructor(value) {
    this.value = value
  }

  map(fn) {
    return new Right(fn(this.value))
  }
}

Right.of = value => new Right(value)
```

具体 `Either` 函数只是对调用 `Left 函子` 或 `Right 函子` 作一层筛选, 其接收 `f`、`g` 两个函数以及一个函子(`Left or Right`)

```js
var Either = function(f, g, functor) {
  switch(functor.constructor) {
    case 'Left':
      return f(functor.value)
    case 'Right':
      return g(functor.value)
    default:
      return f(functor.value)
  }
}
```

使用 demo:

```js
Either((v) => console.log('left', v), (v) => console.log('def', v), left)   // left 1
Either((v) => console.log('rigth', v), (v) => console.log('def', v), rigth) // rigth 2
```

#### Monad 函子

函子会发生嵌套, 比如下面这样:

```js
Functor.of(Functor.of(1)) // Functor { value: Functor { value: 1 } }
```

`Monad 函子` 对外暴露了 `join` 和 `flatmap` 接口, 调用者从而可以扁平化嵌套的函子。

```js
class Monad {
  constructor(value) {
    this.value = value
  }

  map(fn) {
    return new Monad(fn(this.value))
  }

  join() {
    return this.value
  }

  flatmap(fn) {
    return this.map(fn).join()
  }
}

Monad.of = value => new Monad(value)
```

使用方法:

```js
// join
Monad.of(Monad.of(1).join()) // Monad { value: 1 }
Monad.of(Monad.of(1)).join() // Monad { value: 1 }

// flatmap
Monad.of(1).flatmap(r => r + 1)  // 2
```

### 参考

* [mostly-adequate-guide](https://mostly-adequate.gitbooks.io/mostly-adequate-guide)
* [JavaScript 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese)
* [JavaScript 专题之函数柯里化](https://github.com/mqyqingfeng/Blog/issues/42)
* [函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)

<!-- 下面这段代码对阅读文章有帮助, 先记下

```js
var map = curry(function(f, any_functor_at_all) {
  return any_functor_at_all.map(f);
});
``` -->